# AIによる解説

このドキュメントは、AtCoder Beginner Contest 413のC問題「Large Queue」について、AIが提供する詳細な解説です。

## 問題の概要

空の数列 `A` に対して、以下の2種類のクエリを処理する問題です。
1.  **`1 c x`**: 数列 `A` の末尾に、整数 `x` を `c` 個追加する。
2.  **`2 k`**: 数列 `A` の先頭から `k` 個の要素を削除し、削除した要素の総和を出力する。

この問題の最大の特徴は、追加される個数 `c` や削除される個数 `k` が非常に大きい（最大 `10^9`）ことです。

## 解法のアプローチ

### 課題：なぜ愚直な実装ではダメなのか？

もし、数列 `A` を `std::vector` などの動的配列でそのまま管理しようとすると、以下の2つの問題に直面します。
- **メモリ不足**: タイプ1のクエリで `c` が `10^9` の場合、`10^9` 個の要素をメモリに格納しようとして、メモリを使い果たしてしまいます。
- **時間超過**: タイプ2のクエリで `k` が `10^9` の場合、`10^9` 個の要素をループで1つずつ削除・加算していては、制限時間内に到底処理が終わりません。

### 中心のアイデア：ランレングス圧縮（連長圧縮）

この問題を解決する鍵は、**データを圧縮して保持する**ことです。
タイプ1のクエリは「同じ数字 `x` を `c` 個」追加する操作です。つまり、数列 `A` は `(3, 3, 5, 5, 5, 5, ...)` のように、同じ数字のブロックが連なって構成されます。

そこで、`A` の要素を1つずつ格納する代わりに、**「どの数値が、何個連続しているか」** というペア `(個数, 値)`、すなわち `(c, x)` で管理します。これをランレングス圧縮（連長圧縮）と呼びます。

例えば、`A = (3, 3, 5, 5, 5, 5)` は `[(2, 3), (4, 5)]` というペアのリストとして表現できます。

### データ構造の選択：キュー (Queue)

クエリは、数列の「末尾に追加」と「先頭から削除」という操作です。これは、最初に入れたものが最初に出ていく **FIFO (First-In, First-Out)** の原則に従います。このような操作に最適なデータ構造は**キュー (`std::queue`)** です。

私たちは、`long long` 型のペア `pair<long long, long long>` を格納するキューを使って、`(c, x)` のブロックを管理します。

### クエリ処理の詳細

1.  **タイプ1 (`1 c x`) クエリ（追加）**:
    これは非常に簡単です。与えられたペア `(c, x)` をキューの末尾に追加（`push` または `emplace`）するだけです。計算量は `O(1)` です。

2.  **タイプ2 (`2 k`) クエリ（削除）**:
    これがこの問題の核心です。`k` 個の要素を削除するために、キューの先頭からブロックを1つずつ処理していきます。
    `long long ans = 0;` (削除した要素の合計) として初期化し、`k > 0` の間、以下のループを実行します。

    - キューの先頭にあるペア `(c_front, x_front)` を取り出します。
    - **場合分け:**
        - **`k >= c_front` の場合**:
            このブロック `(c_front, x_front)` は丸ごと削除対象になります。
            - `ans` に `c_front * x_front` を加算します。
            - `k` から `c_front` を引きます (`k -= c_front`)。
            - このブロックは完全に処理されたので、キューから削除 (`pop`) します。
        - **`k < c_front` の場合**:
            このブロックの一部だけが削除対象になります。
            - `ans` に `k * x_front` を加算します。
            - ブロックの個数は `k` 個減るので、先頭のペアを `(c_front - k, x_front)` に更新します。
            - `k` は `0` になり、これ以上削除する必要はないのでループを終了します。

### 計算量と注意点

- **計算量**: 一見、タイプ2の `while` ループが遅そうに見えますが、キューに追加された各ペア `(c, x)` は、高々1回しか `pop` されません。部分的に削除される場合も、そのペアに対する最後の操作になります。したがって、`Q` 回のクエリ全体で見ると、各ペアは定数回しかアクセスされません。これを**償却計算量**といい、全体で `O(Q)` となり、非常に高速です。
- **オーバーフロー**: `ans` や `c, x, k` の値は `10^9` オーダーになり、積 `c * x` は `10^{18}` にもなります。これは32ビット整数型 (`int`) には収まりません。必ず **64ビット整数型 (`long long` in C++)** を使用する必要があります。

## サンプルコード (C++)

```cpp
#include <iostream>
#include <queue>
#include <utility>

int main() {
    // 高速化のためのおまじない
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int q;
    std::cin >> q;

    // (個数, 値) のペアを格納するキュー
    std::queue<std::pair<long long, long long>> que;

    while (q--) {
        int type;
        std::cin >> type;
        if (type == 1) {
            long long c, x;
            std::cin >> c >> x;
            // タイプ1: (c, x)のペアをキューに追加
            que.push({c, x});
        } else {
            long long k;
            std::cin >> k;
            long long sum = 0;

            // k個取り出すまでループ
            while (k > 0) {
                // 先頭のペアを取得
                long long count = que.front().first;
                long long value = que.front().second;

                if (k >= count) {
                    // このブロックを丸ごと取り出す
                    sum += count * value;
                    k -= count;
                    que.pop();
                } else {
                    // このブロックの一部を取り出す
                    sum += k * value;
                    // 先頭のペアの個数を更新
                    que.front().first -= k;
                    k = 0; // ループ終了
                }
            }
            std::cout << sum << "\n";
        }
    }

    return 0;
}
```

## コードレビュー

- **メモリ効率**: `(c, x)` という圧縮された形式でデータを保持しているため、数列の実際の長さに関わらず、メモリ使用量を `O(Q)` に抑えることができており、非常に効率的です。
- **計算効率**: 償却 `O(1)` で各クエリを処理できているため、全体の計算量も `O(Q)` となり、高速です。
- **正確性**: `long long` を用いて総和を計算しているため、値が大きくなってもオーバーフローすることなく正確な答えを求めることができます。
- **データ構造の選択**: 問題の性質（FIFO）に完全に合致した `std::queue` を使用しており、コードが直感的で分かりやすくなっています。 