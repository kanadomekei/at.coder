# AIによる解説

このドキュメントは、AtCoder Beginner Contest 413のD問題「Make Geometric Sequence」について、AIが提供する詳細な解説です。

## 問題の概要

与えられた長さ `N` のゼロでない整数列 `A` を適切に並べ替えることで、等比数列を作成できるかどうかを判定する問題です。等比数列とは、隣り合う2項の比（公比 `r`）が常に一定である数列のことを指します。

## 解法のアプローチ

この問題は、`N!`通りの全順列を試すことは計算量的に不可能です。そこで、等比数列が持つ性質を利用して効率的に解くことを目指します。中心的なアイデアは、公比 `r` の絶対値 `|r|` に基づいて場合分けを行うことです。

### 1. 等比数列の基本的な性質

等比数列の項の絶対値は、公比 `r` によって以下のように振る舞います。
- **`|r| > 1`**: 項の絶対値は単調に増加します (例: `2, 4, 8, 16`)。
- **`|r| < 1`**: 項の絶対値は単調に減少します (例: `16, 8, 4, 2`)。
- **`|r| = 1`**:
    - `r = 1`: 全ての項が同じ値になります (例: `5, 5, 5, 5`)。
    - `r = -1`: 絶対値が同じで符号が交互に変わります (例: `5, -5, 5, -5`)。

`|r| > 1` の数列は、逆順に並べると公比が `1/r` (`|1/r| < 1`) となるため、本質的に `|r| < 1` のケースと同じとみなせます。したがって、私たちは**数列の絶対値が単調減少しない（増加するか、変わらない）ケース**のみを考えれば良いことになります。
この考察から、**最初に数列 `A` を絶対値の降順（大きい順）にソートする**という戦略が非常に有効です。

### 2. 判定アルゴリズム

上記を踏まえ、以下のステップで判定を行います。

#### ステップ1: 特殊ケース (`|r| = 1`) の先行判定

これらは単純なパターンなので、最初にチェックします。
- **`r = 1` のケース**: 数列 `A` の要素が**すべて同じ値**かどうかを判定します。これは `O(N)` で確認できます。
- **`r = -1` のケース**: 数列 `A` が `x` と `-x` の**2種類の値のみ**で構成され、その個数が `ceil(N/2)` 個と `floor(N/2)` 個であるかを判定します。これも `O(N)` で確認できます。

#### ステップ2: 一般的なケース (`|r| ≠ 1`) の判定

ステップ1に該当しない場合、以下の手順で判定します。

1.  **絶対値によるソート**:
    数列 `A` を要素の**絶対値の降順**にソートします。
2.  **整数演算による等比数列の検証**:
    ソート後の数列 `B` が等比数列である条件は、すべての `i` で `B[i+1] / B[i]` が一定であることです。しかし、浮動小数点数による割り算は誤差を生む可能性があります。そこで、式を変形し、整数演算だけで判定します。
    `B[i+1] / B[i] = B[i+2] / B[i+1]`
    分母を払うと、以下のようになります。
    `B[i+1] * B[i+1] = B[i] * B[i+2]`
    この関係が、ソート後の数列のすべての隣接する3項について成り立つかを確認します。一つでも成り立たなければ等比数列ではないと判定できます。このチェックは `O(N)` で行えます。

全体の計算量は、ステップ2のソートがボトルネックとなり **`O(N log N)`** となり、制約内で十分に高速です。

## サンプルコード (C++)

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
#include <cmath>

void solve() {
    int n;
    std::cin >> n;
    std::vector<long long> a(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
    }

    // ケース1: r = 1
    // 最初の要素と同じ値の要素の数がn個ならYes
    if (std::count(a.begin(), a.end(), a[0]) == n) {
        std::cout << "Yes" << std::endl;
        return;
    }

    // ケース2: r = -1
    // a[0]の個数と-a[0]の個数の合計がnで、かつ少ない方がn/2個ならYes
    long long p_cnt = std::count(a.begin(), a.end(), a[0]);
    long long n_cnt = std::count(a.begin(), a.end(), -a[0]);
    if (p_cnt + n_cnt == n && std::min(p_cnt, n_cnt) == n / 2) {
        std::cout << "Yes" << std::endl;
        return;
    }
    
    // ケース3: |r| != 1
    // 絶対値の降順でソート
    std::sort(a.begin(), a.end(), [](long long x, long long y) {
        return std::abs(x) > std::abs(y);
    });

    // 整数演算で等比数列になっているかチェック
    for (int i = 0; i <= n - 3; ++i) {
        // a[i+1]^2 != a[i] * a[i+2] ならNo
        // 制約よりa[i]は0でないため、ゼロ除算の心配はない
        if (a[i+1] * a[i+1] != a[i] * a[i+2]) {
            std::cout << "No" << std::endl;
            return;
        }
    }

    std::cout << "Yes" << std::endl;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

## コードレビュー

- **効率性**: `O(N log N)` のソートが計算量の大部分を占めており、これはこの問題の制約に対して非常に効率的です。
- **正確性**: 浮動小数点数を使わずに `b*b == a*c` の形で整数演算のみで比較しているため、精度の問題が起きず、正確な判定が可能です。
- **可読性**: 特殊なケースである `|r|=1` を先に処理することで、メインのロジックがシンプルになり、コードの意図が理解しやすくなっています。 