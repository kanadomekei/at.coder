# AIによる解説

このドキュメントは、AtCoder Beginner Contest 413のB問題「cat 2」について、AIが提供する詳細な解説です。

## 問題の概要

`N` 個の異なる文字列 `S_1, S_2, ..., S_N` が与えられます。この中から**相異なる**2つの文字列 `S_i` と `S_j` を選び、`S_i` と `S_j` をこの順番で連結して新しい文字列を作ります。この操作によって作り出される可能性のある、ユニークな（重複を除いた）文字列は何種類あるかを数える問題です。

## 解法のアプローチ

この問題の要点は、以下の2つをどう処理するかです。
1.  考えられるすべての文字列の組み合わせを生成する方法。
2.  生成した文字列の重複を効率的に除去する方法。

### 1. 全ての組み合わせを生成する

制約を見ると、`N` は最大でも `100` です。これはコンピュータにとっては比較的小さな数です。そのため、すべての組み合わせを全探索（ブルートフォース）で試すことができます。

具体的には、二重の `for` ループを使って、`N` 個の文字列リストから2つの文字列 `S_i` と `S_j` を選び出す全てのペアを考えます。

```
for i from 0 to N-1:
  for j from 0 to N-1:
    // ここで S_i と S_j を使う
```

問題の条件は「**相異なる**整数 `i, j`」なので、`i` と `j` が同じインデックスを指す場合は除外する必要があります。これは `if (i != j)` という条件分岐で簡単に実現できます。

### 2. 重複を効率的に除去する

異なる `(i, j)` のペアを選んでも、結果として同じ文字列が生成されることがあります。
例えば、`S = ["a", "b", "ab"]` の場合、
- `S_0` ("a") と `S_1` ("b") を選ぶと `"ab"` ができます。
- `S_2` ("ab") とはペアを作れませんが、もし `S_3` が "" (空文字列) だったら `S_2` と `S_3` の連結で `"ab"` ができてしまいます。

これらの重複を1つとして数えるために最適なのが、**セット (Set)** というデータ構造です。

#### セットとは？
セットは、以下の特徴を持つコレクションです。
- **重複する要素を許さない**: 同じ要素を複数回追加しようとしても、セット内には1つしか保持されません。
- **順序を持たない**:（実装によりますが）基本的には要素がどの順番で格納されるかは保証されません。

この「重複を許さない」という性質が、今回の問題にぴったりです。

### アルゴリズムの統合

以上の考察から、以下の手順で問題を解くことができます。

1.  生成されたユニークな文字列を格納するための、空の**セット**を用意します。
2.  二重の `for` ループを用いて、`i` と `j` を `0` から `N-1` まで動かします。
3.  ループの中で `i` と `j` が異なる (`i != j`) かどうかをチェックします。
4.  異なっていれば、文字列 `S_i` と `S_j` を連結して新しい文字列 `T = S_i + S_j` を作ります。
5.  生成した文字列 `T` をセットに追加します。セットが自動的に重複を処理してくれます。
6.  すべてのループが終わった後、セットの**要素数（サイズ）**を数えます。これが求める答えです。

### 計算量
- 文字列のペアを生成するのに `O(N^2)`。
- 文字列の連結には、その長さ `L` に比例した時間がかかります (`L <= 20`)。
- セットへの追加も、文字列の長さに依存します。
全体の計算量はおおよそ `O(N^2 * L)` となり、`N=100`, `L=20` でも十分高速に動作します。

## サンプルコード (C++)

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <set>

int main() {
    int n;
    std::cin >> n;

    std::vector<std::string> s(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> s[i];
    }

    // 生成した文字列の重複をなくすためにsetを使う
    std::set<std::string> unique_strings;

    // 二重ループで全てのペア (i, j) を試す
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            // iとjが異なる場合のみ処理する
            if (i != j) {
                // 文字列を連結してsetに追加
                unique_strings.insert(s[i] + s[j]);
            }
        }
    }

    // setのサイズが答え
    std::cout << unique_strings.size() << std::endl;

    return 0;
}
```

## コードレビュー
- **アルゴリズム**: `N` が小さいという制約を活かした、シンプルで分かりやすい全探索アルゴリズムです。
- **データ構造**: 重複を除去するという問題の要件に対して、`std::set` を使うという選択は最適です。コードが簡潔になり、意図も明確です。
- **正確性**: `i != j` の条件を正しくチェックしており、問題文の「相異なる」という要件を満たしています。
- **効率性**: 制約の範囲内で十分に高速に動作するため、パフォーマンス上の問題はありません。 